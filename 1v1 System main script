local Players = game:GetService("Players")
local SoundService = game:GetService("SoundService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local WinnerAnnounce = ReplicatedStorage:WaitForChild("WinnerAnnounce")
local RoundWinAnnounce = ReplicatedStorage:WaitForChild("RoundWinAnnounce")
local PushTool = ReplicatedStorage:WaitForChild("PushTool")

local Stage = script.Parent
local Button = Stage.Button
local Config = Stage.Config
local MainBoard = Stage.MainBoard.SurfaceGui.Frame.Status
local plate1 = Stage.Plate1
local plate2 = Stage.Plate2
local Announcement = Stage:FindFirstChild("Announcement")
local CountdownLabel = Announcement and Announcement:FindFirstChild("Countdown")
local Holder = Stage:WaitForChild("Holder")
local TeleportPoint = Stage.T1.Position

local inMatch = false
local scores = {}
local maxRounds = 3
local currentRound = 0
local countdownTask

local platePlayers = {
	[plate1] = nil,
	[plate2] = nil
}

-- Updates the scoreboard with either Waiting or current score
local function updateMainBoard()
	if not inMatch then
		MainBoard.Text = "Waiting..."
	else
		MainBoard.Text = scores[platePlayers[plate1].UserId] .. " - " .. scores[platePlayers[plate2].UserId]
	end
end

-- Updates plate mini boards with player name and headshot
local function updateBoardForPlate(plate, player)
	local boardName = plate == plate1 and "Board1" or "Board2"
	local sg = plate:FindFirstChild(boardName)
	if not sg then return end
	local frame = sg:FindFirstChild("SurfaceGui") and sg.SurfaceGui.Frame
	if not frame then return end

	if player then
		frame.PlayerName.Text = player.Name
		frame.PlayerIcon.Image = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. player.UserId .. "&width=420&height=420&format=png"
	else
		frame.PlayerName.Text = ""
		frame.PlayerIcon.Image = ""
	end
end

-- Sets holder transparency and collisions
local function setHolderVisibility(visible)
	for _, part in ipairs(Holder:GetChildren()) do
		if part:IsA("BasePart") then
			part.Transparency = visible and 0.5 or 1
			part.CanCollide = visible
		end
	end
end

-- Freeze/unfreeze player (kept for compatibility, always uses same WalkSpeed)
local function freezePlayer(player, freeze)
	local char = player.Character
	if not char then return end
	local hum = char:FindFirstChildOfClass("Humanoid")
	if not hum then return end
	hum.WalkSpeed = 16
	hum.JumpPower = 50
end

-- Plays countdown beep 3x before round starts
local function playFreezeSound(player)
	local sound = Instance.new("Sound")
	sound.SoundId = "rbxassetid://6467449877"
	sound.Volume = 1
	sound.Parent = player.Character and player.Character:FindFirstChild("HumanoidRootPart") or SoundService

	for _ = 1, 3 do
		sound:Play()
		task.wait(1)
	end
	sound:Destroy()
end

-- Plays start sound
local function playAfterFreezeSound(player)
	local sound = Instance.new("Sound")
	sound.SoundId = "rbxassetid://3199238628"
	sound.Volume = 1
	sound.Parent = player.Character and player.Character:FindFirstChild("HumanoidRootPart") or SoundService
	sound:Play()
	game.Debris:AddItem(sound, 3)
end

-- Gives push tool if not present
local function givePushTool(player)
	local bp = player:FindFirstChild("Backpack")
	if not bp then return end
	if bp:FindFirstChild("PushTool") or (player.Character and player.Character:FindFirstChild("PushTool")) then return end
	local toolClone = PushTool:Clone()
	toolClone.Parent = bp
end

-- Removes push tool if present
local function removePushTool(player)
	local bp = player:FindFirstChild("Backpack")
	if bp then
		local tool = bp:FindFirstChild("PushTool")
		if tool then tool:Destroy() end
	end
	if player.Character then
		local tool = player.Character:FindFirstChild("PushTool")
		if tool then tool:Destroy() end
	end
end

-- Shows countdown label and plays freeze/start sounds
local function showCountdownAndFreeze()
	if not CountdownLabel then return end
	for _, player in pairs(platePlayers) do
		freezePlayer(player, true)
	end
	CountdownLabel.Visible = true
	for i = 3, 1, -1 do
		CountdownLabel.Text = tostring(i)
		task.wait(1)
	end
	CountdownLabel.Visible = false
	for _, player in pairs(platePlayers) do
		task.spawn(function()
			playFreezeSound(player)
			playAfterFreezeSound(player)
		end)
	end
	task.wait(3)
	for _, player in pairs(platePlayers) do
		freezePlayer(player, false)
	end
end

-- Picks and shows a random Ender
local function pickRandomEnder()
	local enders = {}
	for _, child in ipairs(Button:GetChildren()) do
		if child.Name == "Ender" then
			table.insert(enders, child)
		end
	end
	if #enders == 0 then return end

	local chosen = enders[math.random(1, #enders)]
	for _, ender in ipairs(enders) do
		for _, desc in ipairs(ender:GetDescendants()) do
			if desc:IsA("BasePart") then
				desc.Transparency = 1
				desc.CanCollide = false
			end
		end
	end
	for _, desc in ipairs(chosen:GetDescendants()) do
		if desc:IsA("BasePart") then
			desc.Transparency = 0
			desc.CanCollide = true
		end
	end
	return chosen
end

-- Starts the match
local function startMatch()
	inMatch = true
	currentRound = 0
	scores = {
		[platePlayers[plate1].UserId] = 0,
		[platePlayers[plate2].UserId] = 0
	}
	updateMainBoard()
	updateBoardForPlate(plate1, platePlayers[plate1])
	updateBoardForPlate(plate2, platePlayers[plate2])
	setHolderVisibility(true)
	task.delay(3, function() setHolderVisibility(false) end)
	pickRandomEnder()

	for _, player in pairs(platePlayers) do
		local char = player.Character
		if char and char:FindFirstChild("HumanoidRootPart") then
			char:PivotTo(CFrame.new(TeleportPoint + Vector3.new(math.random(-3, 3), 5, math.random(-3, 3))))
			freezePlayer(player, true)
			givePushTool(player)
		end
	end

	for _, player in pairs(platePlayers) do
		task.spawn(function()
			playFreezeSound(player)
			playAfterFreezeSound(player)
		end)
	end
	task.wait(3)
	for _, player in pairs(platePlayers) do
		freezePlayer(player, false)
	end
end

-- Resets the stage for the next round
local function resetMatch()
	setHolderVisibility(true)
	task.delay(3, function() setHolderVisibility(false) end)
	pickRandomEnder()

	for _, player in pairs(platePlayers) do
		local char = player.Character
		if char and char:FindFirstChild("HumanoidRootPart") then
			char:PivotTo(CFrame.new(TeleportPoint + Vector3.new(math.random(-3, 3), 5, math.random(-3, 3))))
			freezePlayer(player, true)
			givePushTool(player)
		end
	end

	for _, player in pairs(platePlayers) do
		task.spawn(function()
			playFreezeSound(player)
			playAfterFreezeSound(player)
		end)
	end
	task.wait(3)
	for _, player in pairs(platePlayers) do
		freezePlayer(player, false)
	end
end

-- Cancels countdown if a player leaves
local function cancelCountdown()
	if countdownTask then
		task.cancel(countdownTask)
		countdownTask = nil
	end
end

-- Handles countdown before match begins
local function countdownAndStart()
	countdownTask = task.spawn(function()
		for i = 5, 1, -1 do
			if not (platePlayers[plate1] and platePlayers[plate2] and platePlayers[plate1] ~= platePlayers[plate2]) then
				cancelCountdown()
				updateMainBoard()
				return
			end
			MainBoard.Text = "Starting in " .. i
			MainBoard.TextColor3 = i <= 3 and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
			task.wait(1)
		end
		MainBoard.TextColor3 = Color3.new(1, 1, 1)
		if platePlayers[plate1] and platePlayers[plate2] and platePlayers[plate1] ~= platePlayers[plate2] then
			showCountdownAndFreeze()
			startMatch()
		else
			cancelCountdown()
			updateMainBoard()
		end
		countdownTask = nil
	end)
end

-- Handles clicking an Ender to score
for _, child in ipairs(Button:GetChildren()) do
	if child.Name == "Ender" then
		local partEnd = child:FindFirstChild("PartEnd")
		local cd = partEnd and partEnd:FindFirstChildOfClass("ClickDetector")
		if cd then
			cd.MouseClick:Connect(function(player)
				if not inMatch then return end
				if not scores[player.UserId] then return end
				scores[player.UserId] += 1
				currentRound += 1
				updateMainBoard()

				if scores[player.UserId] >= maxRounds then
					inMatch = false
					MainBoard.Text = player.Name .. " won!"
					local loser = platePlayers[plate1] == player and platePlayers[plate2] or platePlayers[plate1]
					WinnerAnnounce:FireAllClients(player.Name, loser.Name, scores[player.UserId], scores[loser.UserId])
					if player:FindFirstChild("leaderstats") and player.leaderstats:FindFirstChild("Wins") then
						player.leaderstats.Wins.Value += 1
					end
					for _, p in pairs(platePlayers) do
						local char = p.Character
						if char and char:FindFirstChild("HumanoidRootPart") then
							local spawn = workspace:FindFirstChild("SpawnLocation")
							if spawn then
								char:PivotTo(spawn.CFrame + Vector3.new(0, 5, 0))
							end
						end
						freezePlayer(p, false)
						removePushTool(p)
					end
					platePlayers[plate1] = nil
					platePlayers[plate2] = nil
					updateBoardForPlate(plate1, nil)
					updateBoardForPlate(plate2, nil)
					updateMainBoard()
				else
					for _, p in pairs(platePlayers) do
						RoundWinAnnounce:FireClient(p, player.Name, currentRound)
					end
					resetMatch()
				end
			end)
		end
	end
end

-- Handles player stepping on plate
local function onPlayerEnterZone(plate, player)
	if inMatch or platePlayers[plate] then return end
	platePlayers[plate] = player
	updateBoardForPlate(plate, player)
	if platePlayers[plate1] and platePlayers[plate2] and platePlayers[plate1] ~= platePlayers[plate2] then
		countdownAndStart()
	end
end

-- Handles player leaving plate
local function onPlayerLeaveZone(plate, player)
	if inMatch then return end
	if platePlayers[plate] == player then
		platePlayers[plate] = nil
		updateBoardForPlate(plate, nil)
		cancelCountdown()
		updateMainBoard()
	end
end

-- Zone detection setup
local function setupZoneDetection(plate, zoneName)
	local zonePart = plate:WaitForChild(zoneName)
	local touching = {}
	zonePart.Touched:Connect(function(hit)
		local player = Players:GetPlayerFromCharacter(hit.Parent)
		if player and not touching[player] then
			touching[player] = true
			onPlayerEnterZone(plate, player)
		end
	end)
	zonePart.TouchEnded:Connect(function(hit)
		local player = Players:GetPlayerFromCharacter(hit.Parent)
		if player and touching[player] then
			touching[player] = nil
			onPlayerLeaveZone(plate, player)
		end
	end)
end

setupZoneDetection(plate1, "Zone1")
setupZoneDetection(plate2, "Zone2")

-- Final setup: update boards and hide holders
updateMainBoard()
updateBoardForPlate(plate1, nil)
updateBoardForPlate(plate2, nil)
setHolderVisibility(false)
